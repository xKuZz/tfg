\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{spark\PYGZus{}gpu\PYGZus{}batch\PYGZus{}som}\PYG{p}{(}\PYG{n}{rdd\PYGZus{}data}\PYG{p}{,} \PYG{n}{d}\PYG{p}{,} \PYG{n}{max\PYGZus{}iters}\PYG{p}{,} \PYG{n}{rows}\PYG{p}{,} \PYG{n}{cols}\PYG{p}{,} \PYG{n}{smooth\PYGZus{}iters}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,}
                        \PYG{n}{sigma\PYGZus{}0}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{sigma\PYGZus{}f}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{tau}\PYG{o}{=}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{tpb}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{):}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    :param rdd\PYGZus{}data RDD con el conjunto de muestras a evaluar.}
\PYG{l+s+sd}{    :param d Tamaño de una muestra, dimensión del problema.}
\PYG{l+s+sd}{    :param max\PYGZus{}iters Número de iteraciones a realizar.}
\PYG{l+s+sd}{    :param rows Número de filas en el mapa de neuronas.}
\PYG{l+s+sd}{    :param cols Número de columnas en el mapa de neuronas.}
\PYG{l+s+sd}{    :param smooth\PYGZus{}iters Número de iteraciones en las que el parámetro}
\PYG{l+s+sd}{           sigma decrece siguiendo una función gaussiana.}
\PYG{l+s+sd}{    :param sigma\PYGZus{}0 Valor de sigma inicial.}
\PYG{l+s+sd}{    :param sigma\PYGZus{}f Valor de sigma tras alcanzar la iteración smooth\PYGZus{}iters.}
\PYG{l+s+sd}{    :param tau Valor de tau para la función gaussiana.}
\PYG{l+s+sd}{    :param seed Semilla pseudoaleatoria para la generación inicial de pesos.}
\PYG{l+s+sd}{    :param tpb Número de hebras por bloque para la inicialización de pesos y}
\PYG{l+s+sd}{           la actualización final de los pesos.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{c+c1}{\PYGZsh{} 1. Declaramos la estructura de los pesos.}
    \PYG{n}{d\PYGZus{}weights} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{device\PYGZus{}array}\PYG{p}{((}\PYG{n}{rows}\PYG{p}{,} \PYG{n}{cols} \PYG{p}{,}\PYG{n}{d}\PYG{p}{),} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 1.2 Usamos Numba para generar los pesos de forma pseudoaleatoria.}
    \PYG{n}{rng\PYGZus{}states} \PYG{o}{=} \PYG{n}{create\PYGZus{}xoroshiro128p\PYGZus{}states}\PYG{p}{(}\PYG{n}{rows} \PYG{o}{*} \PYG{n}{cols} \PYG{o}{*} \PYG{n}{d}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{n}{seed}\PYG{p}{)}
    \PYG{n}{rand\PYGZus{}weights}\PYG{p}{[(}\PYG{n}{d\PYGZus{}weights}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)} \PYG{o}{//} \PYG{n}{tpb} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tpb}\PYG{p}{](}\PYG{n}{rng\PYGZus{}states}\PYG{p}{,} \PYG{n}{d\PYGZus{}weights}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 1.3 Traemos los pesos de la memoria de la GPU a la memoria del host.}
    \PYG{n}{weights} \PYG{o}{=} \PYG{n}{d\PYGZus{}weights}\PYG{o}{.}\PYG{n}{copy\PYGZus{}to\PYGZus{}host}\PYG{p}{()}

    \PYG{c+c1}{\PYGZsh{} 2. Inicio del proceso iterativo}
    \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{max\PYGZus{}iters}\PYG{p}{):}
        \PYG{c+c1}{\PYGZsh{} 2.a Actualizamos sigma en función de los tau y la iteración.}
        \PYG{k}{if} \PYG{n}{smooth\PYGZus{}iters} \PYG{o+ow}{is} \PYG{n+nb+bp}{None} \PYG{o+ow}{or} \PYG{n}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}iters}\PYG{p}{:}
            \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}0} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{((}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{))}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}f}

        \PYG{n}{sigma\PYGZus{}squared} \PYG{o}{=} \PYG{n}{sigma} \PYG{o}{*} \PYG{n}{sigma}

        \PYG{c+c1}{\PYGZsh{} 2.b Cada nodo del clúster de spark trabajará con un subconjunto}
        \PYG{c+c1}{\PYGZsh{} de las muestras del RDD para encontrar la BMU y realizar la suma}
        \PYG{c+c1}{\PYGZsh{} parcial de su ecucación de actualización de pesos.}
        \PYG{n}{out} \PYG{o}{=} \PYG{n}{rdd\PYGZus{}data}\PYG{o}{.}\PYG{n}{mapPartitions}\PYG{p}{(}\PYG{n}{gpu\PYGZus{}work\PYGZus{}iter}\PYG{p}{(}\PYG{n}{weights}\PYG{p}{,} \PYG{n}{sigma\PYGZus{}squared}\PYG{p}{))}

        \PYG{c+c1}{\PYGZsh{} 2.c En un único nodo usamos la GPU para juntar todas las sumas}
        \PYG{c+c1}{\PYGZsh{}     parciales obtenidas y realizar la división}
        \PYG{n}{out} \PYG{o}{=} \PYG{n}{out}\PYG{o}{.}\PYG{n}{collect}\PYG{p}{()}
        \PYG{n}{numParts} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)} \PYG{o}{//} \PYG{l+m+mi}{2}

        \PYG{n}{partials} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}
        \PYG{n}{finish\PYGZus{}update}\PYG{p}{[}\PYG{n}{rows} \PYG{o}{*} \PYG{n}{cols} \PYG{o}{//} \PYG{n}{tpb} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tpb}\PYG{p}{](}\PYG{n}{weights}\PYG{p}{,} \PYG{n}{partials}\PYG{p}{,} \PYG{n}{numParts}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 3. Devolvemos los pesos obtenidos}
    \PYG{k}{return} \PYG{n}{weights}
\end{Verbatim}
