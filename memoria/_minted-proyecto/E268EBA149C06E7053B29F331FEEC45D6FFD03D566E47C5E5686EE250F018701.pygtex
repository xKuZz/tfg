\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numba} \PYG{k+kn}{import} \PYG{n}{cuda}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{c+c1}{\PYGZsh{} Definimos el kernel}
\PYG{n+nd}{@cuda.jit}
\PYG{k}{def} \PYG{n+nf}{aumentar\PYGZus{}en\PYGZus{}1}\PYG{p}{(}\PYG{n}{un\PYGZus{}array}\PYG{p}{):}
  \PYG{c+c1}{\PYGZsh{} Cogemos el índice de la hebra}
    \PYG{n}{pos} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Si el índice está en el rango del array}
    \PYG{c+c1}{\PYGZsh{} incrementamos su valor}
    \PYG{k}{if} \PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{n}{un\PYGZus{}array}\PYG{o}{.}\PYG{n}{size}\PYG{p}{:}
        \PYG{n}{un\PYGZus{}array}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]} \PYG{o}{+=} \PYG{l+m+mi}{1}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}\PYGZsq{}}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} Declaramos un array de 10000 ceros}
  \PYG{n}{ejemplo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}
  \PYG{c+c1}{\PYGZsh{} Calculamos el número de bloques necesario}
  \PYG{n}{bloques} \PYG{o}{=} \PYG{n}{ejemplo}\PYG{o}{.}\PYG{n}{size} \PYG{o}{//} \PYG{l+m+mi}{128} \PYG{o}{+} \PYG{l+m+mi}{1}
  \PYG{c+c1}{\PYGZsh{} Lanzamos el kernel con bloques de 128 hebras}
  \PYG{n}{aumentar\PYGZus{}en\PYGZus{}1}\PYG{p}{[}\PYG{n}{bloques}\PYG{p}{,} \PYG{l+m+mi}{128}\PYG{p}{](}\PYG{n}{ejemplo}\PYG{p}{)}
\end{Verbatim}
